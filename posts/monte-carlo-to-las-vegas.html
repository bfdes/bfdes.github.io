<!DOCTYPE html><html lang="en"><head><meta charSet="utf8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="theme-color" content="#202020"/><meta name="description" content="Personal blog"/><meta name="author" content="Bruno Fernandes"/><title>bfdes.in</title><link href="data:image/png;base64,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" rel="icon"/><link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&amp;display=swap" rel="stylesheet"/><link href="https://unpkg.com/highlight.js@10.3.1/styles/github.css" rel="stylesheet"/><link href="https://unpkg.com/katex@0.13.9/dist/katex.min.css" rel="stylesheet"/><link href="/styles/main.css" rel="stylesheet"/></head><body><div id="root"><aside id="sidebar"><img class="avatar" src="/images/avatar.jpg" alt="Profile photo"/><div id="nav"><a class="nav-item" href="/posts"><h2>Blog</h2></a><a class="nav-item" href="/about.html"><h2>About</h2></a></div><div id="social"><a class="nav-item" href="https://www.github.com/bfdes"><img class="badge" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RERCMUIwQTM4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RERCMUIwQTI4NkNFMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTMyOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjJBNDE0QUJDOTlBMTExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+8kSqyAAADD5JREFUeNrsXQ2Q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" alt="GitHub link"/></a><a class="nav-item" href="/feed.rss"><img class="badge" src="data:image/png;base64,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" alt="RSS link"/></a></div></aside><div id="content"><div class="post"><h1>Monte Carlo to Las Vegas</h1><p class="meta">15 June 2019 · <span> # <a href="/tags/algorithms.html">Algorithms</a> # <a href="/tags/apis.html">APIs</a></span> · 753 words</p><div class="body"><p>Recently I wrote an algorithms library while following Computer Science courses to understand better the fundamental data structures that underpin modern computing. In the process, I gained an appreciation of the benefits of good API design.</p>
<p>Sometimes, but not always, the goal of exposing a lean library API conflicts with that of writing performant code. Let's look at one such situation I encountered when adding a substring search algorithm to <a href="https://github.com/bfdes/Collections">Collections</a>.</p>
<h2>Monte Carlo algorithms</h2>
<p>Monte Carlo algorithms are those which we can guarantee to terminate in finite time but which may yield an incorrect result now and then.<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> On the other hand, a Las Vegas algorithm is guaranteed to produce a correct result, but we might only be able to obtain a probabilistic measure of its runtime.</p>
<p>It is possible to formulate a Las Vegas variant of an algorithm from the Monte Carlo variant in some cases. The Rabin Karp substring search algorithm has this property.</p>
<h2>Substring search</h2>
<p>Substring search algorithms let us find the position of a search string or pattern <code>p</code> within a larger piece of text <code>t</code>. Suppose our library exposes them as <a href="https://en.wikipedia.org/wiki/Currying">curried functions</a></p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>:</mo><mi>p</mi><mo>↦</mo><mi>t</mi><mo>↦</mo><mi>i</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">f : p \mapsto t \mapsto i,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7054400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.62608em;vertical-align:-0.011em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span></span></span></span></span></div>
<p>where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i \in I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></span> if the search string appears as a substring in the text, and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span> otherwise.<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup></p>
<p>Example usage in Python:</p>
<pre><code class="hljs language-python"><span class="hljs-meta">>>> </span>find(<span class="hljs-string">"needle"</span>)(<span class="hljs-string">"It's like looking for a needle in a haystack"</span>)
<span class="hljs-number">24</span>
<span class="hljs-meta">>>> </span>find(<span class="hljs-string">"nettle"</span>)(<span class="hljs-string">"It's like looking for a needle in a haystack"</span>)
<span class="hljs-number">-1</span>
</code></pre>
<p>The naïve or brute force algorithm loops through every character of search text and attempts to match the search string against the next <code>len(p)</code> characters encountered:</p>
<pre><code class="hljs language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">pattern</span>):</span>
  m = <span class="hljs-built_in">len</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">text</span>):</span>
    n = <span class="hljs-built_in">len</span>(text)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, n):
      <span class="hljs-keyword">if</span>(pattern == text[i:i+m]):
        <span class="hljs-keyword">return</span> i
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>

  <span class="hljs-keyword">return</span> search
</code></pre>
<p>It performs poorly for large text input.<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup> We can do much better by using something like Rabin-Karp search.<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup></p>
<p>Our goal is to enable the client to write the Las Vegas variant of Rabin Karp in terms of the Monte Carlo variant so that the library only has to export one implementation.</p>
<h2>Rabin-Karp</h2>
<p>The Rabin Karp algorithm attempts to find the search string by computing a rolling hash of successive substrings in the search text.<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup> The Monte Carlo variant returns the index that defines the first substring with a hash matching that of the pattern -- if one exists. Note that a hash collision can result in a false positive match.</p>
<p>Looking at code will make the idea clear. Here is a Python implementation of Rabin Karp:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># rabin_karp.py</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">pattern</span>):</span>
  r = <span class="hljs-number">256</span>  <span class="hljs-comment"># Search over ASCII characters</span>
  q = <span class="hljs-number">997</span>  <span class="hljs-comment"># Large prime number</span>
  m = <span class="hljs-built_in">len</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash</span>(<span class="hljs-params">s</span>):</span>
    <span class="hljs-comment"># Hash the first m characters of s</span>
    h = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s[:m]:
      h = (h * r + <span class="hljs-built_in">ord</span>(c)) % q
    <span class="hljs-keyword">return</span> h

  pattern_hash = <span class="hljs-built_in">hash</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">text</span>):</span>
    <span class="hljs-comment"># Compare the rolling hash to the pattern hash</span>
    text_hash = <span class="hljs-built_in">hash</span>(text)
    n = <span class="hljs-built_in">len</span>(text)
    <span class="hljs-keyword">if</span> text_hash == pattern_hash:
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    <span class="hljs-comment"># Precompute r^(m-1) % q for use in removing leading digit</span>
    R = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):
      R = (r * R) % q

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, n):
      <span class="hljs-comment"># Remove contribution from the leading digit</span>
      text_hash = (text_hash + q - R * <span class="hljs-built_in">ord</span>(text[i-m]) % q) % q
      <span class="hljs-comment"># And add contribution from trailing digit</span>
      text_hash = (text_hash * r + <span class="hljs-built_in">ord</span>(text[i])) % q
      <span class="hljs-keyword">if</span> text_hash == pattern_hash:
        <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>  <span class="hljs-comment"># Not found</span>

  <span class="hljs-keyword">return</span> search
</code></pre>
<p>The Las Vegas variant additionally performs an equality check to verify that the strings <code>pattern</code> and <code>text[i-m:i]</code> are the same before returning from the search loop. But this is equivalent to modifying the Monte Carlo variant to call itself on the remaining portion of text if an equality check fails, viz:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> rabin_karp

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">pattern</span>):</span>
  m = <span class="hljs-built_in">len</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">text, start=<span class="hljs-number">0</span></span>):</span>
    i = rabin_karp.find(pattern)(text[start:])
    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    <span class="hljs-keyword">if</span> pattern == text[start+i:start+i+m]:
      <span class="hljs-keyword">return</span> start+i
    <span class="hljs-keyword">return</span> search(text, start+i+<span class="hljs-number">1</span>)

  <span class="hljs-keyword">return</span> search
</code></pre>
<p>So it looks like library consumers can quickly adapt the Monte Carlo variant of the algorithm to create the Las Vegas form if needed.</p>
<h2>Engineering tradeoffs</h2>
<p>It is generally very hard to get a free lunch.<sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup> In this case, reusing code can lead to performance and memory usage issues when search text contains <strong>lots</strong> of false-positive matches.</p>
<p>Each false positive match encountered when <code>find</code> executes</p>
<ol>
<li>creates an extra stack frame, and</li>
<li>results in the hash within <code>rabin_karp.find</code> being recomputed.</li>
</ol>
<p>We can deal with the first problem by simply rewriting <code>find</code> in an iterative fashion:<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup></p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> rabin_karp

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">pattern</span>):</span>
  m = <span class="hljs-built_in">len</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">text</span>):</span>
    start = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
      i = rabin_karp.find(pattern)(text[start:])
      <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
      <span class="hljs-keyword">if</span> pattern == text[start+i:start+i+m]:
        <span class="hljs-keyword">return</span> start+i
      start = start+i+<span class="hljs-number">1</span>

  <span class="hljs-keyword">return</span> search
</code></pre>
<p>We can only solve the second problem by writing the implementation from scratch.</p>
<p>The library can support just the Monte Carlo implementation if it is not likely to be used when false positive matches are unacceptable. Unfortunately, generally speaking, library authors cannot be sure that developers won't use their code in pathological cases.</p>
<h2>Acknowledgements</h2>
<p>I want to thank the people who reviewed the first draft of this blog post. <a href="https://adilparvez.com">Adil Parvez</a> helped me define the tone of the article, and <a href="https://scottw.co.uk">Scott Williams</a> pointed out that it is, in fact, <em>always</em> possible to go from a Las Vegas variant of an algorithm to a Monte Carlo variant.<sup id="fnref-8"><a href="#fn-8" class="footnote-ref">8</a></sup></p>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>More precisely, the result of a Monte Carlo algorithm may be incorrect with a <em>known</em> probability.<a href="#fnref-1" class="footnote-backref">↩</a></p>
</li>
<li id="fn-2">
<p>This API is the best for Rabin Karp because it enables a <em>small</em> optimization: the user can choose to <a href="https://en.wikipedia.org/wiki/Memoization">memoize</a> the search string hash. For example, in</p>
<pre><code class="hljs language-python"><span class="hljs-meta">>>> </span>search = find(<span class="hljs-string">"needle"</span>)
<span class="hljs-meta">>>> </span>search(<span class="hljs-string">"It's like looking for a needle in a haystack"</span>)
<span class="hljs-number">24</span>
<span class="hljs-meta">>>> </span>search(<span class="hljs-string">"It's like a wild goose chase"</span>)
<span class="hljs-number">-1</span>
</code></pre>
<p><code>"needle"</code> has only been hashed once.<a href="#fnref-2" class="footnote-backref">↩</a></p>
</li>
<li id="fn-3">
<p>In the worst-case scenario, the runtime is bounded by <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></span> are the pattern and search text lengths, respectively.<a href="#fnref-3" class="footnote-backref">↩</a></p>
</li>
<li id="fn-4">
<p>Boyer-Moore and Knuth-Morris-Pratt search algorithms are also effective alternatives.<a href="#fnref-4" class="footnote-backref">↩</a></p>
</li>
<li id="fn-5">
<p>The course <a href="https://www.coursera.org/learn/algorithms-part1">Algorithms I</a> does an excellent job in explaining how Rabin-Karp works.<a href="#fnref-5" class="footnote-backref">↩</a></p>
</li>
<li id="fn-6">
<p>Unless you work at Google :P<a href="#fnref-6" class="footnote-backref">↩</a></p>
</li>
<li id="fn-7">
<p>We can get away using recursion when working in a language that supports tail-call optimization. Unfortunately, <a href="https://stackoverflow.com/a/13592002">Python does not</a>.<a href="#fnref-7" class="footnote-backref">↩</a></p>
</li>
<li id="fn-8">
<p>For example, an absurd way of implementing a Monte Carlo variant of Rabin Karp given a Las Vegas variant is to return the correct index on every other invocation and a random one otherwise.<a href="#fnref-8" class="footnote-backref">↩</a></p>
</li>
</ol>
</div></div></div><div class="pagination"><span class="pagination-item"><a href="/posts/property-testing.html">Previous</a></span><span class="pagination-item"><a href="/posts/create-a-class.html">Next</a></span></div></div></div></body></html>