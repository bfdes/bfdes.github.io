<!DOCTYPE html><html lang="en"><head><meta charSet="utf8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="theme-color" content="#202020"/><meta name="description" content="Personal blog"/><meta name="author" content="Bruno Fernandes"/><title>bfdes.in</title><link href="/images/favicon.png" rel="icon"/><link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono&amp;display=swap" rel="stylesheet"/><link href="https://unpkg.com/highlight.js@10.3.1/styles/github.css" rel="stylesheet"/><link href="https://unpkg.com/katex@0.12.0/dist/katex.min.css" rel="stylesheet"/><link href="/styles/main.css" rel="stylesheet"/></head><body><div id="root"><aside id="sidebar"><img class="avatar" src="/images/avatar.jpg" alt="Profile photo"/><div id="nav"><a class="nav-item" href="/posts"><h2>Blog</h2></a><a class="nav-item" href="/about.html"><h2>About</h2></a></div><div id="social"><a class="nav-item" href="https://www.github.com/bfdes"><img class="badge" src="/images/github.png" alt="GitHub link"/></a><a class="nav-item" href="/feed.rss"><img class="badge" src="/images/rss.png" alt="RSS link"/></a></div></aside><div id="content"><div class="post"><h1>Monte Carlo to Las Vegas</h1><p class="meta">15 June 2019 · <span> # <a href="/tags/algorithms.html">Algorithms</a> # <a href="/tags/api.html">API</a></span> · 555 words</p><div class="body"><p>Recently I have been writing an algorithms library while following Computer Science courses to understand better the fundamental data structures that underpin modern computing. In the process, I have gained an appreciation of the benefits of good API design.</p>
<p>Sometimes, but not always, the goal of exposing a lean library API conflicts with that of writing performant code. Let us look at one such situation that I encountered while writing <a href="https://github.com/bfdes/Collections">Collections</a>.</p>
<p>The Monte Carlo class of algorithms are those which we can guarantee to terminate in finite time, but which may yield an incorrect result now and then. A Las Vegas algorithm, on the other hand, is guaranteed to produce a correct result, but we might only be able to obtain a probabilistic measure of its runtime.</p>
<p>In some cases, it is possible to formulate a Las Vegas variant from the Monte Carlo variant of an algorithm.</p>
<p>The Rabin Karp substring search algorithm has this property. Suppose we expose substring search algorithms as functions <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> that accept substrings <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span></span> and return search functions for the text <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span></span>:</p>
<div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo>:</mo><mi>p</mi><mo>↦</mo><mi>t</mi><mo>↦</mo><mi>i</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">f : p \mapsto t \mapsto i,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7054400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.62608em;vertical-align:-0.011em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span></span></span></span></span></div>
<p>where <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">i \in I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span></span> if the substring is found, and <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span> otherwise.</p>
<p>The goal is to enable the client to write Las Vegas variant in terms of the Monte Carlo variant <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span></span> so that the library only has to export one implementation of Rabin Karp.</p>
<h2>Rabin-Karp</h2>
<p>The Rabin Karp algorithm attempts to find the target pattern by computing a rolling hash of successive substrings. In the Monte Carlo variant, we return the index that defines the first substring with a hash matching that of the pattern -- if one exists. Note that a hash collision can result in a false positive match.</p>
<p>Here is a Python implementation of the Monte Carlo form of Rabin Karp as it appears in the book Algorithms II:</p>
<pre><code class="hljs language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monte_carlo</span>(<span class="hljs-params">pattern</span>):</span>
  r = <span class="hljs-number">256</span>  <span class="hljs-comment"># Search over ASCII characters</span>
  q = <span class="hljs-number">997</span>  <span class="hljs-comment"># Large prime number</span>
  m = <span class="hljs-built_in">len</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hash</span>(<span class="hljs-params">s</span>):</span>
    <span class="hljs-comment"># Hash the first m characters of s</span>
    h = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s[:m]:
      h = (h * r + <span class="hljs-built_in">ord</span>(c)) % q
    <span class="hljs-keyword">return</span> h

  pattern_hash = <span class="hljs-built_in">hash</span>(pattern)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">text</span>):</span>
    <span class="hljs-comment"># Compare the rolling hash to the pattern hash</span>
    text_hash = <span class="hljs-built_in">hash</span>(text)
    n = <span class="hljs-built_in">len</span>(text)
    <span class="hljs-keyword">if</span> text_hash == pattern_hash:
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    <span class="hljs-comment"># Precompute r^(m-1) % q for use in removing leading digit</span>
    R = <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):
      R = (r * R) % q

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m, n):
      <span class="hljs-comment"># Remove contribution from the leading digit</span>
      text_hash = (text_hash + q - R * <span class="hljs-built_in">ord</span>(text[i-m]) % q) % q
      <span class="hljs-comment"># And add contribution from trailing digit</span>
      text_hash = (text_hash * r + <span class="hljs-built_in">ord</span>(text[i])) % q
      <span class="hljs-keyword">if</span> text_hash == pattern_hash:
        <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>  <span class="hljs-comment"># Not found</span>

  <span class="hljs-keyword">return</span> search
</code></pre>
<p>The Las Vegas variant additionally performs an equality check to verify that the substrings <code>pattern</code> and <code>text[i-m:i]</code> are the same before returning from the search loop. But this is equivalent to modifying the Monte Carlo variant to call itself on the remaining portion of text if an equality check fails, viz:</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Client code</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">las_vegas</span>(<span class="hljs-params">pattern</span>):</span>
  m = <span class="hljs-built_in">len</span>(pattern)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">text, start=<span class="hljs-number">0</span></span>):</span>
    i = monte_carlo(pattern)(text[start:])  <span class="hljs-comment"># From library</span>
    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
    <span class="hljs-keyword">if</span> pattern == text[start+i:start+i+m]:
      <span class="hljs-keyword">return</span> start+i
    <span class="hljs-keyword">return</span> search(text, start+i+<span class="hljs-number">1</span>)

  <span class="hljs-keyword">return</span> search
</code></pre>
<p>Library consumers can quickly adapt the Monte Carlo variant if they need to, and library authors can reuse implementation code when writing the Las Vegas form of Rabin Karp.</p>
<h2>Eating your Cake</h2>
<p>So what is the problem with reusing code? Well, there are a couple of penalties to be mindful of that only manifest themselves when search text contains lots of false-positive matches.</p>
<ul>
<li>When working in a language that does not come with a tail-call optimising compiler, we must use an iterative version of <code>las_vegas</code> to prevent high stack usage.</li>
<li>Performing the equality check outside <code>monte_carlo</code> means we lose access to the rolling hash within the closure. We can only avoid recomputing it by writing the implementation from scratch.</li>
</ul>
<p>The library can support just the Monte Carlo implementation if it is not likely to be used in situations where false positive matches are unacceptable. Unfortunately, generally speaking, library authors cannot be sure that their code won't be used in pathological cases.</p>
<h2>Acknowledgements</h2>
<p>I want to thank those who reviewed the first draft of this blog post. <a href="https://adilparvez.com">Adil Parvez</a> helped me define the motivation and tone of the article, and <a href="https://scottw.co.uk">Scott Williams</a> pointed out that it is, in fact, possible to go from a Las Vegas variant to a Monte Carlo variant of an algorithm.</p></div></div><div class="pagination"><span class="pagination-item"><a href="/posts/property-based-testing.html">Previous</a></span><span class="pagination-item"><a href="/posts/create-a-class.html">Next</a></span></div></div></div></body></html>